// All the sprites
unsigned char defchar[240] PROGMEM = {
  TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Gray, TS_8b_Gray, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_White, TS_8b_Black, TS_8b_White, TS_8b_Gray, TS_8b_Gray, TS_8b_White, TS_8b_Black, TS_8b_White, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Gray, TS_8b_Gray, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Red, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Red, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Red, TS_8b_Red, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Yellow, TS_8b_Yellow, TS_8b_Blue, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Blue, TS_8b_Yellow, TS_8b_Yellow,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Black, TS_8b_Yellow,
  TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_White,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black
};
unsigned char slpchar[240] PROGMEM = {
  TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Gray, TS_8b_Gray, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Gray, TS_8b_Gray, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_White, TS_8b_Black, TS_8b_White, TS_8b_Gray, TS_8b_Gray, TS_8b_White, TS_8b_Black, TS_8b_White, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Yellow, TS_8b_Yellow, TS_8b_Blue, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Blue, TS_8b_Yellow, TS_8b_Yellow,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Black, TS_8b_Yellow,
  TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_White,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black
};
unsigned char deadchar[240] PROGMEM = {
  TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_Red, TS_8b_White, TS_8b_Red, TS_8b_Gray, TS_8b_Gray, TS_8b_Red, TS_8b_White, TS_8b_Red, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_White, TS_8b_Red, TS_8b_White, TS_8b_Gray, TS_8b_Gray, TS_8b_White, TS_8b_Red, TS_8b_White, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_Red, TS_8b_White, TS_8b_Red, TS_8b_Gray, TS_8b_Gray, TS_8b_Red, TS_8b_White, TS_8b_Red, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Red, TS_8b_Red, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Red, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Red, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Yellow, TS_8b_Yellow, TS_8b_Blue, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Blue, TS_8b_Yellow, TS_8b_Yellow,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Black, TS_8b_Yellow,
  TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_White,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black
};

//bird again not in progmem for now
unsigned char flappyBirdBitmap[204] PROGMEM = {
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Black, TS_8b_White, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_White, TS_8b_White, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Red, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black
};

//ghost haunting you again
unsigned char ghost[361] PROGMEM = {
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Red, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Red, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Black,
  TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black,
  TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black,
  TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black,
  TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black,
  TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black,
  TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black,
  TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black,
  TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black,
  TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black
};

// Modifier icons
unsigned char heart[40]PROGMEM = {
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Red, TS_8b_Black, TS_8b_Red, TS_8b_Black,
  TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red,
  TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red,
  TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red,
  TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black
};

unsigned char lightning[40] PROGMEM = {
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Yellow,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black
};

unsigned char seven[40] PROGMEM = {
  TS_8b_Green, TS_8b_Green, TS_8b_Green, TS_8b_Green, TS_8b_Green,
  TS_8b_Green, TS_8b_Green, TS_8b_Green, TS_8b_Green, TS_8b_Green,
  TS_8b_Green, TS_8b_Black, TS_8b_Black, TS_8b_Green, TS_8b_Green,
  TS_8b_Black, TS_8b_Black, TS_8b_Green, TS_8b_Green, TS_8b_Black,
  TS_8b_Black, TS_8b_Green, TS_8b_Green, TS_8b_Black, TS_8b_Black,
  TS_8b_Green, TS_8b_Green, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Green, TS_8b_Green, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Green, TS_8b_Green, TS_8b_Black, TS_8b_Black, TS_8b_Black
};

unsigned char money[40] PROGMEM = {
  TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow, TS_8b_Black, TS_8b_Black,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow,
  TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow,
  TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Black, TS_8b_Black
};

// Drawing sprites
void drawDef() {
  display.setX(40, 40 + 12 - 1);
  display.setY(25, 25 + 20 - 1);
  display.startData();
  display.writeBuffer(defchar, 12 * 20);
  display.endTransfer();
}
void drawSlp() {
  display.setX(40, 40 + 12 - 1);
  display.setY(25, 25 + 20 - 1);
  display.startData();
  display.writeBuffer(slpchar, 12 * 20);
  display.endTransfer();
}
void drawDead() {
  display.setX(40, 40 + 12 - 1);
  display.setY(25, 25 + 20 - 1);
  display.startData();
  display.writeBuffer(deadchar, 12 * 20);
  display.endTransfer();
}

void drawHeart() { //blood rune
  display.setX(10, 10 + 5 - 1);
  display.setY(30, 30 + 8 - 1);
  display.startData();
  display.writeBuffer(heart, 5 * 8);
  display.endTransfer();
}
void drawLightning() { //agility rune
  display.setX(20, 20 + 5 - 1);
  display.setY(30, 30 + 8 - 1);
  display.startData();
  display.writeBuffer(lightning, 5 * 8);
  display.endTransfer();
}
void drawSeven() { //luck rune
  display.setX(76, 76 + 5 - 1);
  display.setY(30, 30 + 8 - 1);
  display.startData();
  display.writeBuffer(seven, 5 * 8);
  display.endTransfer();
}
void drawMoney() { //fortune rune
  display.setX(86, 86 + 5 - 1);
  display.setY(30, 30 + 8 - 1);
  display.startData();
  display.writeBuffer(money, 5 * 8);
  display.endTransfer();
}

// exit to game menu
void retMenu() {
  display.clearWindow(0, 10, 96, 64);
  mainMenu(0);
}

int16_t gold = 100;
char gold_buffer[11];

byte maxHp = 100; //modded by blood rune
byte hp = 100;
char hp_buffer[8];

byte goldGenRate = 1;

// Control HP
void chkHP() {
  if (hp >= maxHp) {
    hp = maxHp;
  }
  else if (hp <= 0) {
    hp = 0;
  }
}

// Update HP Function
void updateHP() {
  chkHP();
  display.setCursor(0, 10);
  snprintf(hp_buffer, 8, "HP:%03d", hp);
  display.println(hp_buffer);
}

// Control Gold
void chkGold() {
  if (gold >= 10000) {
    gold = 9999;
  }
  else if (gold <= -10000) {
    gold = -9999;
  }
}

// Update Gold Function
void updateGold() {
  chkGold();
  display.setCursor(45, 10);
  snprintf(gold_buffer, 11, "Gold:%04d", gold);
  display.println(gold_buffer);
}

// Quotes to display when revive
//const char * deathQuotes[] PROGMEM = { //Progmem all the things
//  "YOU DIED", //you died
//  "U R finally awake", //you're finally awake
//  "Not Today!", //not today
//  "Deth's 4 poor ppl", //Death's for poor people
//  "Nothing is free!", //Nothing in life is free, even Death.
//  "Meet the New-U!", //Meet the new you! They're like the old you, but more alive!
//  "Welcome Back!",
//  "Fast Travel",
//  "Rolled 1 in life",
//  "Guardian Angel!"
//};
//char deathQ_buffer[17];

void printdQuotes() {
  byte randnum = random(10);
  display.clearWindow(0, 45, 96, 64);
  display.setCursor(1, 52);
  switch (randnum) { // Switched to switch statement to prevent corruption in case of full mem
    case 0:
      display.print(F("YOU DIED"));
      break;
    case 1:
      display.print(F("U R finally awake"));
      break;
    case 2:
      display.print(F("Not Today!"));
      break;
    case 3:
      display.print(F("Deth's 4 poor ppl"));
      break;
    case 4:
      display.print(F("Nothing is free!"));
      break;
    case 5:
      display.print(F("Meet the New-U!"));
      break;
    case 6:
      display.print(F("Welcome Back!"));
      break;
    case 7:
      display.print(F("Fast Travel"));
      break;
    case 8:
      display.print(F("Rolled 1 in life"));
      break;
    case 9:
      display.print(F("Guardian Angel!"));
      break;
  }
}

// If dead then revive
void chkDead() {
  if (hp <= 0) {
    display.clearWindow(40, 25, 12, 20);
    drawDead();
    gold -= 200; //revival will require gold, but can be in debt
    hp += 100;
    display.setCursor(0, 52);
    //byte rnd = random(10);
    //strcpy_P(deathQ_buffer, (char *)pgm_read_word(&(deathQuotes[rnd])));
    //display.println(deathQ_buffer);
    void printdQuotes();
    delay(1500);
    display.clearWindow(0, 52, 96, 64);
    display.setCursor(0, 52);
    display.print(F("Ressurected!"));
    updateHP();
    updateGold();
    display.clearWindow(40, 25, 12, 20);
    drawDef();
  }
}
//randomSeed();

// Its all about the ticks
uint32_t startLTime = 0;
uint32_t endLTime = 0;
uint16_t timeDiff = 0;
uint16_t timeElapsed = 0;

// Tracking time passed in the game itself
void timePassed() {
  startLTime = millis();
  endLTime = millis() + 1;
  timeDiff = endLTime - startLTime;
  timeElapsed += timeDiff;
}

// RTP system to track time passed when not in game and apply parameters for penalty
void RTP() {
  hp -= deduct;
  gold += deduct * goldGenRate;
  deduct = 0;
  atimeElapsed = 0;
  updateHP();
  updateGold();
}

// Health penalty when idle, plus gold generation
void penaltyHP() {
  if (timeElapsed >= 16200) {
    hp -= 1;
    gold += goldGenRate;
    timeElapsed = 0;
    updateHP();
    updateGold();
  }
}

//// Quotes to display when "playing"
//const char * quotes[] PROGMEM = { //Progmem all the things
//  "Visit me often!",
//  "I might be hungry",
//  "Let's play games!",
//  "I could do a nap!",
//  "I lub you!",
//  "Gib food~~~",
//  "Bananaaaaaa",
//  "Food for thoughts",
//  "Don't neglect me",
//  "Study hard!",
//  "Medicines bad",
//  "Take care!"
//};
//char quote_buffer[17];

// Needs the buffer to prevent bombing memory
void printQuote() {
  byte randnum = random(12);
  display.clearWindow(0, 45, 96, 64);
  display.setCursor(1, 52);
  //strcpy_P(quote_buffer, (char *)pgm_read_word(&(quotes[randnum])));
  switch (randnum) {
    case 0:
      display.print(F("Visit me often!"));
      break;
    case 1:
      display.print(F("I might be hungry"));
      break;
    case 2:
      display.print(F("Let's play games!"));
      break;
    case 3:
      display.print(F("I could do a nap!"));
      break;
    case 4:
      display.print(F("I lub you!"));
      break;
    case 5:
      display.print(F("Gib food~~~"));
      break;
    case 6:
      display.print(F("Bananaaaaaa"));
      break;
    case 7:
      display.print(F("Food for thoughts"));
      break;
    case 8:
      display.print(F("Don't neglect me"));
      break;
    case 9:
      display.print(F("Study hard!"));
      break;
    case 10:
      display.print(F("Medicines bad"));
      break;
    case 11:
      display.print(F("Take care!"));
      break;
  }
}

// Quotes to display when "eating"
//const char * eatQuotes[] PROGMEM = { //Progmem all the things
//  "Munch Munch~~",
//  "Yum yummm",
//  "Yummy!",
//  "Delicious!",
//  "Good Food!",
//  "Lamb SAAUCEE",
//  "Meal time!",
//  "I lub food!",
//  "Expensive meal!"
//};
//char equote_buffer[15];

// Needs the buffer to prevent bombing memory
void printeQuote() {
  byte randnum = random(9);
  display.clearWindow(0, 45, 96, 64);
  display.setCursor(1, 52);
  //strcpy_P(equote_buffer, (char *)pgm_read_word(&(eatQuotes[randnum])));
  switch (randnum) {
    case 0:
      display.print(F("Munch Munch~~"));
      break;
    case 1:
      display.print(F("Yum yummm"));
      break;
    case 2:
      display.print(F("Yummy!"));
      break;
    case 3:
      display.print(F("Delicious!"));
      break;
    case 4:
      display.print(F("Good Food!"));
      break;
    case 5:
      display.print(F("Lamb SAAUCEE"));
      break;
    case 6:
      display.print(F("Meal time!"));
      break;
    case 7:
      display.print(F("I lub food!"));
      break;
    case 8:
      display.print(F("Expensive meal!"));
      break;
  }
}

//Inventory management
String inventory[10] = { //note, m to find mythic may clash
  "Empty", "Empty",
  "Empty", "Empty",
  "Empty", "Empty",
  "Empty", "Empty",
  "Empty", "Empty"
};

String runeSlots[2] = {"Empty", "Empty"}; //edit here to cheat in runes like ma,mb, mf, ml for mythic fortune and mythic luck (required to drop mythic items in goldmine)

byte invSpace() {
  byte space = 0;
  for (byte x = 0; x < 10; x++) { //is there std::find?
    if (inventory[x] == "Empty") {
      space++;
    }
  }
  return space;
}

byte receiveLoot(String item) {
  for (byte x = 0; x < 10; x++) {
    if (inventory[x] == "Empty") {  //is there std::find?
      inventory[x] = item;
      return 1; //success
    }
  }
  return 0; //failed, inventory full
}

void destroyLoot(byte index) {
  inventory[index] = "Empty";
}

byte equipRune(byte index, byte slot) {
  String tempRune = runeSlots[slot]; //store the temp rune to exchange into the inventory
  if (inventory[index] == "Empty") {
    return 0; //equipping failed
  }
  if (inventory[index][1] == runeSlots[0][1] || inventory[index][1] == runeSlots[1][1]) {
    return 0; //cannot equip same type of rune
  }
  runeSlots[slot] = inventory[index]; //equip to rune slot
  inventory[index] = tempRune; //replace item in inventory to previous rune or empty
  return 1;
}

byte unequipRune(byte slot) {
  if (invSpace() < 1) {
    return 0; //failed, no space to unequip
  }
  if (receiveLoot(runeSlots[slot]) != 1) {
    return 0; //failed, no space to unequip * 2nd check
  }
  runeSlots[slot] = "Empty";
  return 1;
}

char getRuneRarity(byte slot) {
  return runeSlots[slot][0];
}

void loop1() {
  byte hpRegenRate = 1;
  byte foodCost = 8;
  chkDead();
  RTP();
  updateGold();
  display.clearWindow(0, 45, 96, 64);
  drawDef();
  display.setCursor(0, 52);
  display.print(F("MeoWelcome Back~!"));
  for (byte rs = 0; rs < 2; rs++) {
    if (runeSlots[rs] != "Empty") { //lbfa
      if (runeSlots[rs].indexOf('b') > 0) { //blood rune
        drawHeart();
        switch (getRuneRarity(rs)) { //your health will not increase from equipping a rune.. cos that is cheating (unequip > equip repeat)
          case 'c':
            maxHp = 115;
            break;
          case 'u':
            maxHp = 135;
            break;
          case 'r':
            maxHp = 170;
            break;
          case 'm':
            maxHp = 210;
            break;
        }
      }
      if (runeSlots[rs].indexOf('l') > 0) { //luck rune
        drawSeven();
        switch (getRuneRarity(rs)) {
          case 'c':
            goldGenRate = 2; //gold gen rate
            break;
          case 'u':
            goldGenRate = 3;
            break;
          case 'r':
            goldGenRate = 5;
            break;
          case 'm':
            goldGenRate = 10;
            break;
        }
      }
      if (runeSlots[rs].indexOf('f') > 0) { //fortune rune
        drawMoney();
        switch (getRuneRarity(rs)) {
          case 'c':
            foodCost = 7; //food cost rate
            break;
          case 'u':
            foodCost = 6;
            break;
          case 'r':
            foodCost = 4;
            break;
          case 'm':
            foodCost = 1;
            break;
        }
      }
      if (runeSlots[rs].indexOf('a') > 0) { //agility rune
        drawLightning();
        switch (getRuneRarity(rs)) {
          case 'c':
            hpRegenRate = 2; //health regen rate change based on runes
            break;
          case 'u':
            hpRegenRate = 3;
            break;
          case 'r':
            hpRegenRate = 6;
            break;
          case 'm':
            hpRegenRate = 15;
            break;
        }
      }
    }
  }
  delay(750);
  while (1) { // Void loop simulation
    if (display.getButtons(TSButtonUpperLeft)) { //This is the "condition" to break out of this infinite loop.
      retMenu();
      break;
    }
    if (display.getButtons(TSButtonLowerLeft)) { //Play/Quotes
      display.clearWindow(0, 52, 96, 64);
      printQuote();
      updateHP();
      updateGold();
      delay(1000);
    }
    if (display.getButtons(TSButtonUpperRight)) { //Feed
      if (gold < foodCost) {
        display.clearWindow(0, 52, 96, 64);
        display.setCursor(0, 52);
        display.print(F("Not enough Gold"));
        delay(1000);
      }
      else {
        display.clearWindow(0, 52, 96, 64);
        display.setCursor(0, 52);
        printeQuote();
        hp += hpRegenRate * 2;
        gold -= foodCost;
        updateHP();
        updateGold();
        delay(1000);
      }
    }
    if (display.getButtons(TSButtonLowerRight)) { //Sleep
      display.clearWindow(0, 52, 96, 64);
      display.setCursor(0, 52);
      display.print(F("I am sleepwy..."));
      display.clearWindow(40, 25, 12, 20);
      drawSlp();
      delay(1000);
      for (byte i = 0; i < 10; i++) {
        delay(1000);
        display.clearWindow(0, 52, 96, 64);
        display.setCursor(0, 52);
        delay(1000);
        display.print(F("Zzzzzzzzzzzzz...."));
        hp += hpRegenRate;
        gold -= 5; // We charge rent!
        updateHP();
        updateGold();
      }
      display.clearWindow(0, 52, 96, 64);
      display.setCursor(0, 52);
      display.print(F("Ahh~! A good nap!"));
      display.clearWindow(40, 25, 12, 20);
      drawDef();
      updateHP();
      updateGold();
    }
    chkDead();
    updateGold();
    timePassed();
    penaltyHP();
  }
}

// Tamagold here
String lootRarity[7] = {"E", "c", "u", "G", "r", "m", "J"}; //empty, common, uncommon, Gold, rare, mythic, Jackpot
String lootPart[4] = {"l", "b", "f", "a"}; //luck, blood, fortune, agility
//emptyChance = 10;
//commonChance = 5;
//uncommonChance = 3;
//goldChance = 3;
//rareChance = 1;
//mythicChance = 0;
//jackpot = 1;

void loop2() { //lootbox game
  String lootRandomizer[21];
  byte curLocation = 1;
  byte curDigged = 0;
  short jackpot = 1000;
  byte coinGain = 20;
  byte baseChances[7] = {10, 6, 3, 3, 1, 0, 1};

  //check runes
  for (byte rs = 0; rs < 2; rs++) {
    if (runeSlots[rs] != "Empty") { //lbfa
      if (runeSlots[rs].indexOf('l') > 0) { //luck rune, mod baseChances, chances stack
        baseChances[0] = baseChances[0] - 1;
        baseChances[2] = baseChances[2] + 1;
        switch (getRuneRarity(rs)) {
          case 'u':
            baseChances[0] = baseChances[0] - 1;
            baseChances[4] = baseChances[4] + 1;
            break;
          case 'r':
            baseChances[0] = baseChances[0] - 2;
            baseChances[4] = baseChances[4] + 1;
            baseChances[5] = baseChances[5] + 1;
            break;
          case 'm':
            baseChances[0] = baseChances[0] - 3;
            baseChances[4] = baseChances[4] + 1;
            baseChances[5] = baseChances[5] + 1;
            baseChances[6] = baseChances[6] + 1;
            break;
        }
      }
      if (runeSlots[rs].indexOf('f') > 0) { //fortune rune
        jackpot += 200;
        coinGain += 10;
        switch (getRuneRarity(rs)) {
          case 'u':
            jackpot += 200;
            coinGain += 10;
            break;
          case 'r':
            jackpot += 400;
            coinGain += 20;
            break;
          case 'm':
            jackpot += 600;
            coinGain += 30;
            break;
        }
      }
    }
  }

  byte rd = 0;
  byte digTime = 0; //10G*n to play
  while (rd < 21) { //the random is exclusive so is 0 to 6
    //using a while loop for a controlled looper, there may be slightly more than 21 iterations due to a 0 chance at mythics
    byte rType = random(0, 7);
    byte rChance = random(0, 11);
    byte lType = random(0, 4);

    if (baseChances[rType] == 0) { //skip, do not increment
      continue;
    }

    if (baseChances[rType] >= rChance) { //success roll
      switch (rType) { //breaking is in the switch not breaking the for loop
        case 0: //empty!
        case 3: //gold!
        case 6: //jackpot!
          lootRandomizer[rd] = lootRarity[rType];
          break;
        case 1://common!
        case 2://uncommon!
        case 4://rare!
        case 5://mythic!
          lootRandomizer[rd] = lootRarity[rType] + lootPart[lType];
          break;
      }
    }
    else {
      continue; //skip do not increment
    }
    rd++;
    //Serial.print("Round");
    //Serial.print("rd");
    //Serial.print(lootRandomizer[rd]);
  }
  delay(750);
  while (1) {
    if (display.getButtons(TSButtonUpperLeft)) { //This is the "condition" to break out of this infinite loop.
      retMenu();
      break;
    }
    if (display.getButtons(TSButtonLowerLeft)) { //move next
      if (curLocation < 21) {
        display.setCursor(0, 10);
        display.print(F("                          ")); //clear display line
        curLocation += 1;
        display.setCursor(0, 50);
        display.print(F("                          ")); //clear display line
        display.setCursor(0, 50);
        display.print(10 * (digTime + 1));
        display.print(F(" Gold to dig"));
      }
    }
    if (display.getButtons(TSButtonUpperRight)) { //move previous
      if (curLocation > 1) {
        display.setCursor(0, 10);
        display.print(F("                          ")); //clear display line
        curLocation -= 1;
        display.setCursor(0, 50);
        display.print(F("                          ")); //clear display line
        display.setCursor(0, 50);
        display.print(10 * (digTime + 1));
        display.print(F(" Gold to dig"));
      }
    }
    if (display.getButtons(TSButtonLowerRight)) {
      //some way to save this thing
      display.setCursor(0, 50);
      display.print(F("                          ")); //clear display line
      display.setCursor(0, 50);
      if (lootRandomizer[curLocation - 1] == "none") {
        display.print(F("Nothing here"));
      }
      else if (gold < 10 * (digTime + 1)) {
        display.print(F("Not enough Gold."));
      }
      else {
        if (lootRandomizer[curLocation - 1] == "E") {
          display.print(F("Oops! Empty here"));
          lootRandomizer[curLocation - 1] = "none";
          digTime++;
          gold -= 10 * digTime;
        }
        else if (lootRandomizer[curLocation - 1] == "G") {
          display.print(F("+"));
          display.print(coinGain);
          display.print(F(" Gold"));
          lootRandomizer[curLocation - 1] = "none";
          digTime++;
          gold += coinGain;
        }
        else if (lootRandomizer[curLocation - 1] == "J") {
          display.print(F("+"));
          display.print(jackpot);
          display.print(F(" Jackpot!"));
          lootRandomizer[curLocation - 1] = "none";
          digTime++;
          gold += jackpot;
        }
        else {
          if (receiveLoot(lootRandomizer[curLocation - 1]) == 1) {
            String dprint = "";
            switch (lootRandomizer[curLocation - 1][0]) {
              case 'c':
                dprint = "Common";
                break;
              case 'u':
                dprint = "Uncommon";
                break;
              case 'r':
                dprint = "Rare";
                break;
              case 'm':
                dprint = "Mythic";
                break;
            }
            display.print("+" + dprint + " Item!");
            lootRandomizer[curLocation - 1] = "none";
            digTime++;
            gold -= 10 * digTime;
          }
          else  {
            display.print(F("Inventory Full!"));
          }
        }
      }
    }
    display.setCursor(0, 10);
    display.print(F("debug loot: "));
    display.print(curLocation);
    display.print(F(".."));
    display.print(lootRandomizer[curLocation - 1]);
    display.setCursor(0, 20);
    for (byte y = 0; y < 3; y++) { //weird loop for 3 rows..?
      display.setCursor(0, 20 + (y * 10));
      for (byte x = y * 7; x < (y * 7) + 7; x++) {
        if (curLocation == (x + 1)) {
          display.print(F("O "));
        }
        else {
          if (lootRandomizer[x] == "none") {
            display.print(F("- "));
          }
          else {
            display.print(F("X "));
          }
        }
      }
    }
  }
}

// Tamaboom here
String bombs[21];
void loop3() {

  byte curLocation = 1;
  byte sweeped = 0;
  byte all = 0;
  byte goldChance = 5;
  byte goldGain = 5;
  byte dodgeRate = 0;

  for (byte rs = 0; rs < 2; rs++) {
    if (runeSlots[rs] != "Empty") { //lbfa
      if (runeSlots[rs].indexOf('b') > 0) { //blod rune
        switch (getRuneRarity(rs)) { //your health will not increase from equipping a rune.. cos that is cheating (unequip > equip repeat)
          case 'c':
            maxHp = 115;
            break;
          case 'u':
            maxHp = 135;
            break;
          case 'r':
            maxHp = 170;
            break;
          case 'm':
            maxHp = 210;
            break;
        }
      }
      if (runeSlots[rs].indexOf('l') > 0) { //luck rune
        drawSeven();
        switch (getRuneRarity(rs)) {
          case 'c':
            goldChance = 6; //gold to bomb ratio
            break;
          case 'u':
            goldChance = 7;
            break;
          case 'r':
            goldChance = 8;
            break;
          case 'm':
            goldChance = 10;
            break;
        }
      }
      if (runeSlots[rs].indexOf('f') > 0) { //fortune rune
        drawMoney();
        switch (getRuneRarity(rs)) {
          case 'c':
            goldGain = 6; //gold per dig rate
            break;
          case 'u':
            goldGain = 7;
            break;
          case 'r':
            goldGain = 9;
            break;
          case 'm':
            goldGain = 15;
            break;
        }
      }
      if (runeSlots[rs].indexOf('a') > 0) { //agility rune
        drawLightning();
        switch (getRuneRarity(rs)) {
          case 'c':
            dodgeRate = 8; //dodge rate
            break;
          case 'u':
            dodgeRate = 17;
            break;
          case 'r':
            dodgeRate = 29;
            break;
          case 'm':
            dodgeRate = 55;
            break;
        }
      }
    }
  }
  //try creating a random loot table bomb ratio 2:3
  for (byte i = 0; i < 21; i++) {
    byte rnd = random(0, goldChance);
    bombs[i] = rnd >= 3 ? "O" : "B";
    if (rnd >= 3) {
      all++;
    }
  }
  delay(750);
  display.setCursor(0, 50);
  display.print(all);
  display.print(F(" Gold spots!"));
  while (1) {
    if (display.getButtons(TSButtonUpperLeft)) { //This is the "condition" to break out of this infinite loop.
      retMenu();
      break;
    }
    //Put whatever game function you have here
    if (display.getButtons(TSButtonLowerLeft)) { //select location next
      if (curLocation < 21) {
        curLocation += 1;
      }
    }
    if (display.getButtons(TSButtonUpperRight)) { //select location previous
      if (curLocation > 1) {
        curLocation -= 1;
      }
    }
    if (display.getButtons(TSButtonLowerRight)) { //dig dig
      //some way to save this thing
      display.setCursor(0, 50);
      if (bombs[curLocation - 1] == "O") {
        display.print(F("+"));
        sweeped++;
        all--;
        display.print(goldGain * sweeped);
        display.print(F(" Gold, "));
        display.print(all);
        display.print(F(" left"));
        bombs[curLocation - 1] = "X";

        gold += goldGain * sweeped;

        if (all == 0) {
          display.clearWindow(0, 10, 96, 64);
          display.setCursor(0, 30);
          display.print(F("Yay! you win!"));
          display.setCursor(0, 40);
          display.print(F("+100 Gold Extra!"));
          gold += 100;
          delay(2000);
          //end gamehere
          retMenu();
          break;
        }
      }
      else if (bombs[curLocation - 1] == "B") { //no longer loses on one bomb, but when out of health
        //agility rune
        byte rollHit = random(0, 100); //roll a hit, if higher than dodge rate, then get hit
        if (dodgeRate > rollHit) {
          display.setCursor(0, 50);
          bombs[curLocation - 1] = "X";
          display.print(F("Dodged a bomb!   "));
          display.print(hp);
        }
        else {
          hp -= 20;
          updateHP();
          if (hp <= 0) {
            display.clearWindow(0, 10, 96, 64);
            display.setCursor(0, 30);
            display.print(F("Boom! you lose!"));
            delay(2000);
            //end gamehere
            retMenu();
            break;
          }
          display.setCursor(0, 50);
          bombs[curLocation - 1] = "X";
          display.print(F("Ow! HP Left: "));
          display.print(hp);
        }
      }
      else {
        display.print(F("Nothing here!"));
      }
    }
    display.setCursor(0, 10);
    display.print(F("Debug loot: "));
    display.print(curLocation);
    display.print(F(".."));
    display.print(bombs[curLocation - 1]);
    display.setCursor(0, 20);
    for (byte y = 0; y < 3; y++) { //weird loop for 3 rows..?
      display.setCursor(0, 20 + (y * 10));

      for (byte x = y * 7; x < (y * 7) + 7; x++) {
        if (curLocation == (x + 1)) {
          display.print(F("O "));
        }
        else {
          if (bombs[x] == "X") {
            display.print(F("- "));
          }
          else {
            display.print(F("X "));
          }
        }
      }
    }
  }
}

void takeDamage(byte hpLoss) { //if hp loss is too much then set hp to 0
  if (hp < hpLoss) {
    hp = 0;
  }
  else {
    hp -= hpLoss;
  }
}

// Dungeons! You cannot exit until you die or escape successfully
void loop4() {

  if (hp <= 0) { //not allowed to enter without health
    display.setCursor(0, 30);
    display.print(F("Revive first"));
    delay(1000);
    retMenu();
    return;
  }

  //battle data
  byte currentTurn = 0; //1 for enemy, 2 for ally, 0 for out of combat
  byte doRollEnemy = 1; //0 while the enemy still alive
  byte willBlockEnemy = 0; //1 for defense

  //enemy data
  byte enemyHealth = 0; //ghost: 40-60, bird: 55-95
  byte enemyDamage = 0;
  byte enemyAttacks = 1; //2 with Quick
  byte enemyType = 0; //0 is ghost, 1 is bird
  byte enemyColor = 0; //0-15, random color, color doesnt matter
  byte enemyPrefix = 0; //0: Edge +6-12Dmg, 1: Tank +10-20Hp, 2: Quick +1 AttackTurn, 3: Hide +30% dodge chance
  byte enemyPrefixBuff = 0;
  byte enemySuffix = 0; //0: none, 1: slave +25hp +5dmg +alwaysRare, 2: boss +100hp +20dmg +alwaysMythic
  byte enemyGReward = 0;
  String enemyItemReward = "Empty";

  //ally data
  byte escapeChance = 25; //15 base too low
  byte stimPrice = 40; //stim is always more expensive than passive healing as it is a dungeon
  byte stims = 1; //stim wont lose turns
  byte defHealMin = 5; //defense will lose turn
  byte attackDamage = 12;
  byte extraTurnChance = 0; //chance when attacking to do an additional turn, there is no limit to this

  for (byte rs = 0; rs < 2; rs++) {
    if (runeSlots[rs] != "Empty") { //lbfa
      if (runeSlots[rs].indexOf('b') > 0) { //blod rune
        switch (getRuneRarity(rs)) { //your health will not increase from equipping a rune.. cos that is cheating (unequip > equip repeat)
          case 'c':
            maxHp = 115;
            attackDamage = 14;
            break;
          case 'u':
            attackDamage = 18;
            maxHp = 135;
            break;
          case 'r':
            attackDamage = 25;
            maxHp = 170;
            break;
          case 'm':
            attackDamage = 40;
            maxHp = 210;
            break;
        }
      }
      if (runeSlots[rs].indexOf('l') > 0) { //luck rune
        drawSeven();
        switch (getRuneRarity(rs)) {
          case 'c':
            escapeChance = 35; //easier escape per rarity
            break;
          case 'u':
            escapeChance = 45;
            break;
          case 'r':
            escapeChance = 60;
            break;
          case 'm':
            escapeChance = 100; //100% chance of escaping
            break;
        }
      }
      if (runeSlots[rs].indexOf('f') > 0) { //fortune rune
        drawMoney();
        switch (getRuneRarity(rs)) {
          case 'c':
            defHealMin = 4; //defensive healing minimum requirement lowered
            stims = 2; //extra stims
            break;
          case 'u':
            defHealMin = 3;
            stims = 2;
            break;
          case 'r':
            defHealMin = 2;
            stims = 3;
            break;
          case 'm':
            defHealMin = 0; //always heal regardless
            stims = 4; //alot of stims
            break;
        }
      }
      if (runeSlots[rs].indexOf('a') > 0) { //agility rune
        drawLightning();
        switch (getRuneRarity(rs)) {
          case 'c':
            extraTurnChance = 7; //dodge rate
            break;
          case 'u':
            extraTurnChance = 16;
            break;
          case 'r':
            extraTurnChance = 30;
            break;
          case 'm':
            extraTurnChance = 66;
            break;
        }
      }
    }
  }

  while (1) {
    if (doRollEnemy == 1) {
      display.clearWindow(0, 10, 96, 64);
      display.setCursor(0, 20);
      display.print(F("Rolling enemy.."));
      //generate enemy
      enemyType = random(0, 2); //0 is ghost, 1 is bird
      enemyHealth = enemyType == 0 ? random(40, 61) : random(55, 96); //ghost: 40-60, bird: 55-95
      enemyDamage = enemyType == 0 ? random(12, 19) : random(8, 13); //ghost: 12-18 dmg, bird: 8-12 dmg
      enemyColor = random(0, 8); //0-8, random color, color doesnt matter
      enemyPrefix = random(0, 4); //0: Edge +6-12Dmg, 1: Tank +10-20Hp, 2: Quick +1 AttackTurn, 3: Hide +30% dodge chance

      switch (enemyPrefix) {
        case 0:
          enemyPrefixBuff = random(6, 13);
          enemyDamage += enemyPrefixBuff; //just immediately add the buff here
          break;
        case 1:
          enemyPrefixBuff = random(10, 21);
          enemyHealth += enemyPrefixBuff; //just immediately add the buff here
          break;
        case 2:
          enemyPrefixBuff = 1;
          enemyAttacks = 2;
          break;
        case 3:
          enemyPrefixBuff = 30; //evasion is calculated separately
          break;
      }

      //weighted suffix
      enemySuffix = random(0, 11); //0: none, 1: slave +25hp +5dmg +alwaysRare, 2: boss +100hp +20dmg +alwaysMythic

      //if you dare enter the dungeon, you will always get uncommon - mythic runes, no less
      if (enemySuffix > 8) {
        enemySuffix = 2; //BOSS
        enemyHealth += 100; //no more rng here
        enemyDamage += 20;
        enemyGReward = random(100, 251); //100-250 gold

        enemyItemReward = "m" + lootPart[random(0, 4)]; //mythic
      }
      else if (enemySuffix > 5) {
        enemySuffix = 1; //SLAVE
        enemyHealth += 25; //no more rng here
        enemyDamage += 5;
        enemyGReward = random(40, 71); //40-70 gold
        enemyItemReward = "r" + lootPart[random(0, 4)]; //rare
      }
      else {
        enemySuffix = 0; //MOB
        enemyGReward = random(30, 61); //30-60 gold
        enemyItemReward = "u" + lootPart[random(0, 4)]; //uncommon
      }

      //warmup and show enemy name
      delay(1000); //delay for the suspense
      display.clearWindow(0, 10, 96, 64);
      display.setCursor(0, 10);
      display.print(F("You will Fight:"));
      display.setCursor(0, 20);
      switch (enemyPrefix) {
        case 0:
          display.print(F("Edge v"));
          break;
        case 1:
          display.print(F("Tank v"));
          break;
        case 2:
          display.print(F("Quick v"));
          break;
        case 3:
          display.print(F("Hide v"));
          break;
      }
      display.print(enemyColor); //just print the number
      display.print("-");
      display.print(enemyType == 0 ? "Ghost" : "Bird");
      //      switch(enemyType) {
      //        case 0:
      //          display.print("Ghost");
      //          break;
      //        case 1:
      //          display.print("Bird");
      //          break;
      //      }
      display.setCursor(0, 30);
      switch (enemySuffix) {
        case 0:
          display.print(F("Mob"));
          break;
        case 1:
          display.print(F("Slave"));
          break;
        case 2:
          display.print(F("BOSS"));
          break;
      }

      delay(3000);
      display.clearWindow(0, 10, 96, 64);
      currentTurn = 2;
      updateHP(); //print hp at 0,10
      display.setCursor(50, 10); //print stim at right side
      display.print(F("Stim:"));
      display.print(stims);
      
      //print tamago and enemy at around 10,20 and 45,20
      display.setX(10, 10 + 12 - 1); //draw tamago
      display.setY(20, 20 + 20 - 1);
      display.startData();
      display.writeBuffer(defchar, 12 * 20);
      display.endTransfer();

      //generate enemy sprite
      display.setX(60, 60 + (enemyType == 0 ? 19 - 1 : 17 - 1)); //draw enemy
      display.setY(25, 25 + (enemyType == 0 ? 19 - 1 : 12 - 1));
      display.startData();

      //generate sprite from enemy def
      //TS_8b_Black
      //TS_8b_White
      //TS_8b_Blue
      //TS_8b_Red
      //TS_8b_Yellow
      //TS_8b_Green
      //TS_8b_Brown
      //TS_8b_Gray

      //if ghost, 361, if bird 204
      unsigned char enemy[enemyType == 0 ? 361 : 204];

      for (short i = 0; i < (enemyType == 0 ? 361 : 204); i++) {
        //flappyBirdBitmap / ghost
        enemy[i] = (enemyType == 0 ? ghost[i] : flappyBirdBitmap[i]);
        //base color edit
        if (enemy[i] == (enemyType == 0 ? TS_8b_Red : TS_8b_Yellow)) {
          switch (enemyColor) {
            case 0:
              enemy[i] = TS_8b_Black;
              break;
            case 1:
              enemy[i] = TS_8b_White;
              break;
            case 2:
              enemy[i] = TS_8b_Blue;
              break;
            case 3:
              enemy[i] = TS_8b_Red;
              break;
            case 4:
              enemy[i] = TS_8b_Yellow;
              break;
            case 5:
              enemy[i] = TS_8b_Green;
              break;
            case 6:
              enemy[i] = TS_8b_Brown;
              break;
            case 7:
              enemy[i] = TS_8b_Gray;
              break;
          }
        }
      }

      //display.writeBuffer(enemyType == 0? ghost : flappyBirdBitmap, enemyType == 0? 361 : 204);
      display.writeBuffer(enemy, enemyType == 0 ? 361 : 204);
      display.endTransfer();

      display.setCursor(0, 50);
      display.print(F("Enemy HP:"));
      display.print(enemyHealth);

      //do roll random enemy
      //bottom is show Enemy HP: 100 on first round
      doRollEnemy = 0;
    }

    if (currentTurn == 1) {
      //enemy turn!

      if (willBlockEnemy) {
        willBlockEnemy = 0; //no damage done
        display.setCursor(0, 50);
        display.print(F("Blocked Enemy!"));
      }
      else { //no rng here because too much rng already
        takeDamage(enemyAttacks == 2 ? enemyDamage * 2 : enemyDamage); //Quicks will attack twice.. without rng
        updateHP();
        display.setCursor(0, 50);
        display.print(F("Taken "));
        display.print(enemyAttacks == 2 ? enemyDamage * 2 : enemyDamage);
        display.print(F(" Dmg!"));
      }

      if (hp <= 0) {
        display.clearWindow(0, 10, 96, 64);
        display.setCursor(0, 30);
        display.print(F("You died."));

        delay(2000);
        retMenu();
        break;
      }
      else {
        currentTurn = 2;
      }
    }

    if (display.getButtons(TSButtonUpperLeft)) { //escape

      if (currentTurn == 0) {
        retMenu();
        break;
      }
      else if (currentTurn != 2) {
        display.setCursor(0, 50);
        display.print(F("Not your Turn!"));
      }
      else {
        byte escapeRoll = random(0, 100);
        if (escapeChance > escapeRoll) {
          display.clearWindow(0, 10, 96, 64);
          display.setCursor(0, 30);
          display.print(F("Escaped!")); //random quotes?

          delay(2000);
          retMenu();
          break;
        }
        else {
          currentTurn = 1;
          display.setCursor(0, 50);
          display.print(F("Escape Failed."));
          delay(1000);
        }
      }
    }

    if (display.getButtons(TSButtonUpperRight)) { //stim

      if (currentTurn != 2) {
        display.setCursor(0, 50);
        display.print(F("Not your Turn!       "));
      }
      else if (hp >= maxHp) { //no need to stim
        display.setCursor(0, 50);
        display.print(F("At Max Health       "));
      }
      else if (stims == 0) {
        display.setCursor(0, 50);
        display.print(F("No more Stims       "));
      }
      else if (gold < stimPrice) {
        display.setCursor(0, 50);
        display.print(F("Not enough Gold     "));
      }
      else {
        stims--;
        hp += 30;
        updateHP();
        display.setCursor(0, 50);
        display.print("Healed! HP: ");
        display.print(hp);
        display.setCursor(50, 10); //print health packs at right side
        display.print("Stim:");
        display.print(stims);
        delay(750);
        display.setCursor(0, 50);
        display.print(F("Continue Attack!"));
      }
    }
    if (display.getButtons(TSButtonLowerLeft)) { //attack

      if (currentTurn != 2) {
        display.setCursor(0, 50);
        display.print(F("Not your Turn!       "));
      }
      else if (hp > 0) { //if we are not dead
        if (enemyPrefix == 3) { //if the enemy has Hide prefix
          byte canDodge = random(0, 100);
          if (canDodge <= enemyPrefixBuff) { //fixed at 30% cos too much rng already
            display.setCursor(0, 50);
            display.print(F("Enemy Dodged"));
          }
          else {
            if (enemyHealth < attackDamage) {
              enemyHealth = 0;
            }
            else {
              enemyHealth -= attackDamage; //deal attackdamage to enemy hp
            }
            display.setCursor(0, 50);
            display.print(F("Hit! HP:"));
            display.print(enemyHealth);
          }
        }
        else {
          if (enemyHealth < attackDamage) {
            enemyHealth = 0;
          }
          else {
            enemyHealth -= attackDamage; //deal attackdamage to enemy hp
          }
          display.setCursor(0, 50);
          display.print(F("Hit! HP:"));
          display.print(enemyHealth);
          display.print(F("      "));
        }
        delay(750);
      }

      if (enemyHealth <= 0) {
        display.clearWindow(0, 10, 96, 64);
        display.setCursor(0, 20);
        display.print(F("Enemy Defeated"));
        display.setCursor(0, 30);
        if (receiveLoot(enemyItemReward) == 1) {
          display.print("You got " + enemyItemReward);
        }
        else {
          display.print(F("No Inventory Space")); //no space for loot :c
        }
        display.setCursor(0, 40);
        display.print(F("You earned "));
        display.print(enemyGReward);
        display.print(F(" Gold"));

        gold += enemyGReward;
        if (stims < 5) {
          stims += 1; //free healthpack after victory
        }

        delay(2000); //additional 2 seconds to view the loot
        doRollEnemy = 1;
      }
      else {
        if (extraTurnChance > 0) {
          byte eChance = random(0, 100);
          if (extraTurnChance > eChance) { //extra turn stuff
            currentTurn = 2;
            display.setCursor(0, 50);
            display.print(F("Extra Turn!"));
          }
          else {
            currentTurn = 1;
          }
        }
        else {
          currentTurn = 1;
        }
      }
      delay(750);
    }
    if (display.getButtons(TSButtonLowerRight)) { //defend and heal

      if (currentTurn != 2) {
        display.setCursor(0, 50);
        display.print(F("Not your Turn!     "));
      }
      else {
        willBlockEnemy = 1; //block enemy next turn
        byte willHeal = random(11);

        if (willHeal > defHealMin) {
          hp += willHeal;
          updateHP();
          display.setCursor(0, 50);
          display.print(F("Defend! HP:"));
          display.print(hp);
        }
        else {
          display.setCursor(0, 50);
          display.print(F("Will Defend!     "));
        }
        currentTurn = 1;
        delay(1000);
      }
    }
  }
}

//centering them sprites just for inventory
void drawCenterHeart() { //blood rune
  display.setX(43, 43 + 5 - 1);
  display.setY(32, 32 + 8 - 1);
  display.startData();
  display.writeBuffer(heart, 5 * 8);
  display.endTransfer();
}
void drawCenterLightning() { //agility rune
  display.setX(43, 43 + 5 - 1);
  display.setY(32, 32 + 8 - 1);
  display.startData();
  display.writeBuffer(lightning, 5 * 8);
  display.endTransfer();
}
void drawCenterSeven() { //luck rune
  display.setX(43, 43 + 5 - 1);
  display.setY(32, 32 + 8 - 1);
  display.startData();
  display.writeBuffer(seven, 5 * 8);
  display.endTransfer();
}
void drawCenterMoney() { //fortune rune
  display.setX(43, 43 + 5 - 1);
  display.setY(32, 32 + 8 - 1);
  display.startData();
  display.writeBuffer(money, 5 * 8);
  display.endTransfer();
}

// Inventory Menu
void loop5() {
  byte curLocation = 0;
  byte sel = 0;
  display.clearWindow(0, 10, 96, 64);
  display.setCursor(28, 11);
  display.print(curLocation + 1); // for pagination
  display.print(F(" / 10"));
  display.setCursor(85, 32);
  display.print(F(">"));
  while (1) {
    if (display.getButtons(TSButtonUpperLeft)) { //This is the "condition" to break out of this infinite loop.
      retMenu();
      break;
    }
    // next
    if (display.getButtons(TSButtonLowerRight)) {
      if (sel == 1) { //equip to slot 2
        display.clearWindow(0, 10, 96, 64);
        display.setCursor(0, 30);
        if (equipRune(curLocation, 1) == 1) {
          display.print("Slot 2 Equipped!");
        }
        else {
          display.print("Cannot Equip.");
        }
        delay(1000);
        loop5(); //may cause stack overflow? break works after the end of the next loop5
        break;
      }
      else {
        if (curLocation < 9) {
          display.clearWindow(0, 10, 96, 64);
          display.setCursor(28, 11);
          display.print(curLocation + 1);
          display.print(F(" / 10"));
          if (curLocation < 8) {
            display.setCursor(85, 32);
            display.print(F(">"));
          }
          display.setCursor(4, 32);
          display.print(F("<"));
          curLocation += 1;
          delay(100);
        }
      }
    }
    // back
    if (display.getButtons(TSButtonLowerLeft)) {
      if (sel == 1) { //destroy equipment
        display.clearWindow(0, 10, 96, 64);
        display.setCursor(0, 30);
        destroyLoot(curLocation);
        display.print("Destroyed Rune!");
        delay(1000);
        loop5(); //may cause stack overflow? break works after the end of the next loop5
        break;
      }
      else {
        if (curLocation > 0) {
          display.clearWindow(0, 10, 96, 64);
          display.setCursor(28, 11);
          display.print(curLocation);
          display.print(F(" / 10"));
          display.setCursor(85, 32);
          display.print(F(">"));
          if (curLocation > 1) {
            display.setCursor(4, 32);
            display.print(F("<"));
          }
          curLocation -= 1;
          delay(100);
        }
      }
    }
    if (display.getButtons(TSButtonUpperRight)) {
      // Eqp, Uneqp and trash function here
      String curItem = inventory[curLocation];
      if (inventory[curLocation] == "Empty") {
        //do nothing
      }
      else {
        if (sel == 0) {
          sel = 1;
          display.clearWindow(0, 10, 96, 64);
          display.setCursor(0, 48);
          display.print(F("< Trash"));
          display.setCursor(75, 16);
          display.print(F("S1 >"));
          display.setCursor(75, 48);
          display.print(F("S2 >"));
          display.setCursor(0, 30);
          display.print("Equip Rune?");
          delay(2000);
        }
        else if (sel == 1) { //equip to slot 1
          display.clearWindow(0, 10, 96, 64);
          display.setCursor(0, 30);
          if (equipRune(curLocation, 0) == 1) {
            display.print("Slot 1 Equipped!");
          }
          else {
            display.print("Cannot Equip.");
          }
          delay(1000);
          loop5(); //may cause stack overflow? break works after the end of the next loop5
          break;
        }
      }
    }
    if (sel == 0) {
      display.setCursor(28, 11);
      display.print(curLocation + 1);
      display.print(F(" / 10"));
      // Traversing the array
      //for (byte inv = 0; inv < 10; inv++) {
        if (inventory[curLocation] == "Empty") {
          display.setCursor(34, 32);
          display.print(F("Empty"));
        }
        else {
          // Detecting rune type and rarity
          switch (inventory[curLocation][0]) { //setting rarity
            case 'c':
              display.setCursor(29, 50);
              display.print(F("Common"));
              break;
            case 'u':
              display.setCursor(25, 50);
              display.fontColor(TS_8b_Green, TS_8b_Black);
              display.print(F("Uncommon"));
              display.fontColor(defaultFontColor, defaultFontBG);
              break;
            case 'r':
              display.setCursor(34, 50);
              display.fontColor(TS_8b_Blue, TS_8b_Black);
              display.print(F("Rare"));
              display.fontColor(defaultFontColor, defaultFontBG);
              break;
            case 'm':
              display.setCursor(31, 50);
              display.fontColor(TS_8b_Yellow, TS_8b_Black);
              display.print(F("Mythic"));
              display.fontColor(defaultFontColor, defaultFontBG);
              break;
          }

          switch (inventory[curLocation][1]) {
            case 'b':
              drawCenterHeart();
              break;
            case 'l':
              drawCenterSeven();
              break;
            case 'f':
              drawCenterMoney();
              break;
            case 'a':
              drawCenterLightning();
              break;
          }
        }
      //}
    }
    //Put whatever game function you have here
  }
}
