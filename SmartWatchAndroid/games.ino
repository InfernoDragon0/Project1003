// All the sprites
unsigned char defchar[240] PROGMEM = {
  TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Gray, TS_8b_Gray, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_White, TS_8b_Black, TS_8b_White, TS_8b_Gray, TS_8b_Gray, TS_8b_White, TS_8b_Black, TS_8b_White, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Gray, TS_8b_Gray, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Red, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Red, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Red, TS_8b_Red, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Yellow, TS_8b_Yellow, TS_8b_Blue, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Blue, TS_8b_Yellow, TS_8b_Yellow,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Black, TS_8b_Yellow,
  TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_White,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black
};
unsigned char slpchar[240] PROGMEM = {
  TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Gray, TS_8b_Gray, TS_8b_White, TS_8b_White, TS_8b_White, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Gray, TS_8b_Gray, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_White, TS_8b_Black, TS_8b_White, TS_8b_Gray, TS_8b_Gray, TS_8b_White, TS_8b_Black, TS_8b_White, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Yellow, TS_8b_Yellow, TS_8b_Blue, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Blue, TS_8b_Yellow, TS_8b_Yellow,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Black, TS_8b_Yellow,
  TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_White,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black
};
unsigned char deadchar[240] PROGMEM = {
  TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_Red, TS_8b_White, TS_8b_Red, TS_8b_Gray, TS_8b_Gray, TS_8b_Red, TS_8b_White, TS_8b_Red, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_White, TS_8b_Red, TS_8b_White, TS_8b_Gray, TS_8b_Gray, TS_8b_White, TS_8b_Red, TS_8b_White, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Gray, TS_8b_Red, TS_8b_White, TS_8b_Red, TS_8b_Gray, TS_8b_Gray, TS_8b_Red, TS_8b_White, TS_8b_Red, TS_8b_Gray, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Gray, TS_8b_Gray, TS_8b_Gray, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Red, TS_8b_Red, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Red, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Red, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Yellow, TS_8b_Yellow, TS_8b_Blue, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Blue, TS_8b_Yellow, TS_8b_Yellow,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Blue, TS_8b_Black, TS_8b_Yellow,
  TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Blue, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_White,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_White, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black
};
// Modifier icons
unsigned char heart[40]PROGMEM = {
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Red, TS_8b_Black, TS_8b_Red, TS_8b_Black,
  TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red,
  TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red,
  TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Red,
  TS_8b_Black, TS_8b_Red, TS_8b_Red, TS_8b_Red, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Red, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black
};

unsigned char lightning[40] PROGMEM = {
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Yellow,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black, TS_8b_Black
};

unsigned char seven[40] PROGMEM = {
  TS_8b_Green, TS_8b_Green, TS_8b_Green, TS_8b_Green, TS_8b_Green,
  TS_8b_Green, TS_8b_Green, TS_8b_Green, TS_8b_Green, TS_8b_Green,
  TS_8b_Green, TS_8b_Black, TS_8b_Black, TS_8b_Green, TS_8b_Green,
  TS_8b_Black, TS_8b_Black, TS_8b_Green, TS_8b_Green, TS_8b_Black,
  TS_8b_Black, TS_8b_Green, TS_8b_Green, TS_8b_Black, TS_8b_Black,
  TS_8b_Green, TS_8b_Green, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Green, TS_8b_Green, TS_8b_Black, TS_8b_Black, TS_8b_Black,
  TS_8b_Green, TS_8b_Green, TS_8b_Black, TS_8b_Black, TS_8b_Black
};

unsigned char money[40] PROGMEM = {
  TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow, TS_8b_Black, TS_8b_Black,
  TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow, TS_8b_Black, TS_8b_Black,
  TS_8b_Black, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow,
  TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Black, TS_8b_Yellow,
  TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Yellow, TS_8b_Black,
  TS_8b_Black, TS_8b_Black, TS_8b_Yellow, TS_8b_Black, TS_8b_Black
};

void drawDef() {
  display.setX(40, 40 + 12 - 1);
  display.setY(25, 25 + 20 - 1);
  display.startData();
  display.writeBuffer(defchar, 12 * 20);
  display.endTransfer();
}
void drawSlp() {
  display.setX(40, 40 + 12 - 1);
  display.setY(25, 25 + 20 - 1);
  display.startData();
  display.writeBuffer(slpchar, 12 * 20);
  display.endTransfer();
}
void drawDead() {
  display.setX(40, 40 + 12 - 1);
  display.setY(25, 25 + 20 - 1);
  display.startData();
  display.writeBuffer(deadchar, 12 * 20);
  display.endTransfer();
}

void drawHeart() { //blood rune
  display.setX(10, 10 + 5 - 1);
  display.setY(30, 30 + 8 - 1);
  display.startData();
  display.writeBuffer(heart, 5 * 8);
  display.endTransfer();
}
void drawLightning() { //agility rune
  display.setX(20, 20 + 5 - 1);
  display.setY(30, 30 + 8 - 1);
  display.startData();
  display.writeBuffer(lightning, 5 * 8);
  display.endTransfer();
}
void drawSeven() { //luck rune
  display.setX(76, 76 + 5 - 1);
  display.setY(30, 30 + 8 - 1);
  display.startData();
  display.writeBuffer(seven, 5 * 8);
  display.endTransfer();
}
void drawMoney() { //fortune rune
  display.setX(86, 86 + 5 - 1);
  display.setY(30, 30 + 8 - 1);
  display.startData();
  display.writeBuffer(money, 5 * 8);
  display.endTransfer();
}

void retMenu() {
  display.clearWindow(0, 10, 96, 64);
  mainMenu(0);
}

// Modifiers variables

int16_t gold = 100;
char gold_buffer[11];


byte maxHp = 100; //modded by blood rune
byte hp = 100;
char hp_buffer[8];


// Control HP
void chkHP() {
  if (hp >= maxHp) {
    hp = maxHp;
  }
  else if (hp <= 0) {
    hp = 0;
  }
}

// Update HP Function
void updateHP() {
  chkHP();
  display.setCursor(0, 10);
  snprintf(hp_buffer, 8, "HP:%03d", hp);
  display.println(hp_buffer);
}

// Control Gold
void chkGold() {
  if (gold >= 10000) {
    gold = 9999;
  }
  else if (gold <= -10000) {
    gold = -9999;
  }
}

// Update Gold Function
void updateGold() {
  chkGold();
  display.setCursor(45, 10);
  snprintf(gold_buffer, 11, "Gold:%04d", gold);
  display.println(gold_buffer);
}

// If dead then revive
void chkDead() {
  if (hp <= 0) {
    display.clearWindow(40, 25, 12, 20);
    drawDead();
    gold -= 50;
    hp += 100;
    display.setCursor(0, 52);
    display.print(F("You Lose. Reviving.."));
    delay(1500);
    display.clearWindow(0, 52, 96, 64);
    display.setCursor(0, 52);
    display.print(F("Ressurected!"));
    updateHP();
    updateGold();
    display.clearWindow(40, 25, 12, 20);
    drawDef();
  }
}

// Its all about the ticks
uint32_t startLTime = 0;
uint32_t endLTime = 0;
uint16_t timeDiff = 0;
uint16_t timeElapsed = 0;

void timePassed() {
  startLTime = millis();
  endLTime = millis() + 1;
  timeDiff = endLTime - startLTime;
  timeElapsed += timeDiff;
}

void RTP() {
  hp -= deduct;
  deduct = 0;
  atimeElapsed = 0;
  updateHP();
}

// Health penalty when idle
void penaltyHP() {
  if (timeElapsed >= 16200) {
    hp -= 1;
    timeElapsed = 0;
    updateHP();
  }
}

// Quotes to display when "playing"
const char * quotes[] PROGMEM = { //Progmem all the things
  "Visit me often!",
  "I might be hungry",
  "Let's play games!",
  "I could do a nap!",
  "I lub you!",
  "Gib food~~~",
  "Bananaaaaaa",
  "Food for thoughts",
  "Don't neglect me",
  "Study hard!",
  "Medicines bad",
  "Take care!"
};
char quote_buffer[17];

void printQuote() {
  byte randnum = random(13);
  display.clearWindow(0, 45, 96, 64);
  display.setCursor(1, 52);
  strcpy_P(quote_buffer, (char *)pgm_read_word(&(quotes[randnum])));
  display.println(quote_buffer);
}

//Inventory management
String inventory[10] = { //note, m to find mythic may clash
  "Empty", "Empty",
  "Empty", "Empty",
  "Empty", "Empty",
  "Empty", "Empty",
  "Empty", "Empty"
};

String runeSlots[2] = {"Empty", "Empty"}; //edit here to cheat in runes like mf, ml for mythic fortune and mythic luck (required to drop mythic items in goldmine)

byte invSpace() {
  byte space = 0;
  for (byte x = 0; x < 9; x++) { //is there std::find?
    if (inventory[x] == "Empty") {
      space++;
    }
  }
  return space;
}

byte receiveLoot(String item) {
  for (byte x = 0; x < 9; x++) {
    if (inventory[x] == "Empty") {  //is there std::find?
      inventory[x] = item;
      return 1; //success
    }
  }
  return 0; //failed, inventory full
}

void destroyLoot(byte index) {
  inventory[index] = "Empty";
}

byte equipRune(byte index, byte slot) {
  String tempRune = runeSlots[slot]; //store the temp rune to exchange into the inventory
  if (inventory[index] == "Empty") {
    return 0; //equipping failed
  }
  runeSlots[slot] = inventory[index]; //equip to rune slot
  inventory[index] = tempRune; //replace item in inventory to previous rune or empty
  return 1;
}

byte unequipRune(byte slot) {
  if (invSpace() < 1) {
    return 0; //failed, no space to unequip
  }
  if (receiveLoot(runeSlots[slot]) != 1) {
    return 0; //failed, no space to unequip * 2nd check
  }
  runeSlots[slot] = "Empty";
  return 1;
}

char getRuneRarity(byte slot) {
  return runeSlots[slot][0];
}

void loop1() {
  chkDead();
  RTP();
  updateGold();
  display.clearWindow(0, 45, 96, 64);
  drawDef();
  display.setCursor(0, 52);
  display.print(F("MeoWelcome Back~!"));
  for (byte rs = 0; rs < 2; rs++) {
    if (runeSlots[rs] != "Empty") { //lbfa
      if (runeSlots[rs].indexOf('b') > 0) { //blod rune
        drawHeart();
        switch(getRuneRarity(rs)) { //your health will not increase from equipping a rune.. cos that is cheating (unequip > equip repeat)
          case 'c':
            maxHp = 115;
            break;
          case 'u':
            maxHp = 135;
            break;
          case 'r':
            maxHp = 170;
            break;
          case 'm':
            maxHp = 210;
            break;
        }
        
      }
      if (runeSlots[rs].indexOf('l') > 0) { //luck rune
        drawSeven();
      }
      if (runeSlots[rs].indexOf('f') > 0) { //fortune rune
        drawMoney();
      }
      if (runeSlots[rs].indexOf('a') > 0) { //agility rune
        drawLightning();
      }
    }
  }
  delay(1000);
  while (1) { // Void loop simulation
    if (display.getButtons(TSButtonUpperLeft)) { //This is the "condition" to break out of this infinite loop.
      retMenu();
      break;
    }
    if (display.getButtons(TSButtonLowerLeft)) { //Play/Quotes
      display.clearWindow(0, 52, 96, 64);
      printQuote();
      updateHP();
      updateGold();
      delay(1000);
    }
    if (display.getButtons(TSButtonUpperRight)) { //Feed
      display.clearWindow(0, 52, 96, 64);
      display.setCursor(0, 52);
      display.print(F("Munch Munch~~"));
      hp += 2;
      updateHP();
      updateGold();
      delay(1000);
    }
    if (display.getButtons(TSButtonLowerRight)) { //Sleep
      display.clearWindow(0, 52, 96, 64);
      display.setCursor(0, 52);
      display.print(F("I am sleepwy..."));
      display.clearWindow(40, 25, 12, 20);
      drawSlp();
      delay(1000);
      for (uint8_t i = 0; i < 10; i++) {
        delay(1000);
        display.clearWindow(0, 52, 96, 64);
        display.setCursor(0, 52);
        delay(1000);
        display.print(F("Zzzzzzzzzzzzz...."));
        hp += 1;
        updateHP();
      }
      display.clearWindow(0, 52, 96, 64);
      display.setCursor(0, 52);
      display.print(F("Ahh~! A good nap!"));
      display.clearWindow(40, 25, 12, 20);
      drawDef();
      updateHP();
      updateGold();
    }
    chkDead();
    updateGold();
    timePassed();
    penaltyHP();
  }
}

// Tamagold here

String lootRarity[7] = {"E", "c", "u", "G", "r", "m", "J"}; //empty, common, uncommon, Gold, rare, mythic, Jackpot
String lootPart[4] = {"l", "b", "f", "a"}; //luck, blood, fortune, agility
//emptyChance = 10;
//commonChance = 5;
//uncommonChance = 3;
//goldChance = 3;
//rareChance = 1;
//mythicChance = 0;
//jackpot = 1;

void loop2() { //lootbox game
  String lootRandomizer[21];
  byte curLocation = 1;
  byte curDigged = 0;
  short jackpot = 1000;
  byte coinGain = 20;

  byte baseChances[7] = {10, 6, 3, 3, 1, 0, 1};

  //check runes
  for (byte rs = 0; rs < 2; rs++) {
    if (runeSlots[rs] != "Empty") { //lbfa
      if (runeSlots[rs].indexOf('l') > 0) { //luck rune, mod baseChances, chances stack
        baseChances[0] = baseChances[0] - 1;
        baseChances[2] = baseChances[2] + 1;
        switch (getRuneRarity(rs)) {
          case 'u':
            baseChances[0] = baseChances[0] - 1;
            baseChances[4] = baseChances[4] + 1;
            break;
          case 'r':
            baseChances[0] = baseChances[0] - 2;
            baseChances[4] = baseChances[4] + 1;
            baseChances[5] = baseChances[5] + 1;
            break;
          case 'm':
            baseChances[0] = baseChances[0] - 3;
            baseChances[4] = baseChances[4] + 1;
            baseChances[5] = baseChances[5] + 1;
            baseChances[6] = baseChances[6] + 1;
            break;
        }

      }
      if (runeSlots[rs].indexOf('f') > 0) { //fortune rune
        jackpot += 200;
        coinGain += 10;
        switch (getRuneRarity(rs)) {
          case 'u':
            jackpot += 200;
            coinGain += 10;
            break;
          case 'r':
            jackpot += 400;
            coinGain += 20;
            break;
          case 'm':
            jackpot += 600;
            coinGain += 30;
            break;
        }
      }
    }
  }

  byte rd = 0;
  byte digTime = 0; //10G*n to play
  while (rd < 21) { //the random is exclusive so is 0 to 6
    //using a while loop for a controlled looper, there may be slightly more than 21 iterations due to a 0 chance at mythics
    byte rType = random(0, 7);
    byte rChance = random(0, 11);
    byte lType = random(0, 4);


    if (baseChances[rType] == 0) { //skip, do not increment
      continue;
    }

    if (baseChances[rType] >= rChance) { //success roll
      switch (rType) { //breaking is in the switch not breaking the for loop
        case 0: //empty!
        case 3: //gold!
        case 6: //jackpot!
          lootRandomizer[rd] = lootRarity[rType];
          break;

        case 1://common!
        case 2://uncommon!
        case 4://rare!
        case 5://mythic!
          lootRandomizer[rd] = lootRarity[rType] + lootPart[lType];
          break;
      }
    }
    else {
      continue; //skip do not increment
    }
    rd++;
    //Serial.print("Round");
    //Serial.print("rd");
    //Serial.print(lootRandomizer[rd]);
  }

  while (1) {
    if (display.getButtons(TSButtonUpperLeft)) { //This is the "condition" to break out of this infinite loop.
      retMenu();
      break;
    }

    if (display.getButtons(TSButtonLowerLeft)) { //move next
      if (curLocation < 21) {
        display.setCursor(0, 10);
        display.print("                          "); //clear display line
        curLocation += 1;
        display.setCursor(0, 50);
        display.print("                          "); //clear display line
        display.setCursor(0, 50);
        display.print(10 * (digTime + 1));
        display.print(" Gold to dig");
      }

    }
    if (display.getButtons(TSButtonUpperRight)) { //move previous
      if (curLocation > 1) {
        display.setCursor(0, 10);
        display.print("                          "); //clear display line
        curLocation -= 1;
        display.setCursor(0, 50);
        display.print("                          "); //clear display line
        display.setCursor(0, 50);
        display.print(10 * (digTime + 1));
        display.print(" Gold to dig");
      }
    }

    if (display.getButtons(TSButtonLowerRight)) {
      //some way to save this thing

      display.setCursor(0, 50);
      display.print("                          "); //clear display line

      display.setCursor(0, 50);

      if (lootRandomizer[curLocation - 1] == "none") {
        display.print("Nothing here");
      }
      else if (gold < 10 * (digTime + 1)) {
        display.print("Not enough Gold.");
      }
      else {
        if (lootRandomizer[curLocation - 1] == "E") {
          display.print("Oops! Empty here");
          lootRandomizer[curLocation - 1] = "none";
          digTime++;
          gold -= 10 * digTime;
        }
        else if (lootRandomizer[curLocation - 1] == "G") {
          display.print("+");
          display.print(coinGain);
          display.print(" Gold");
          lootRandomizer[curLocation - 1] = "none";
          digTime++;
          gold += coinGain;
        }
        else if (lootRandomizer[curLocation - 1] == "J") {
          display.print("+");
          display.print(jackpot);
          display.print(" Jackpot!");
          lootRandomizer[curLocation - 1] = "none";
          digTime++;
          gold += jackpot;
        }
        else {
          if (receiveLoot(lootRandomizer[curLocation - 1]) == 1) {
            String dprint = "";
            switch (lootRandomizer[curLocation - 1][0]) {
              case 'c':
                dprint = "Common";
                break;
              case 'u':
                dprint = "Uncommon";
                break;
              case 'r':
                dprint = "Rare";
                break;
              case 'm':
                dprint = "Mythic";
                break;
            }
            display.print("+" + dprint + " Item!");
            lootRandomizer[curLocation - 1] = "none";
            digTime++;
            gold -= 10 * digTime;
          }
          else  {
            display.print("Inventory Full!");
          }
        }
      }
    }


    display.setCursor(0, 10);
    display.print("debug loot: ");
    display.print(curLocation);
    display.print("..");
    display.print(lootRandomizer[curLocation - 1]);

    display.setCursor(0, 20);
    for (byte y = 0; y < 3; y++) { //weird loop for 3 rows..?
      display.setCursor(0, 20 + (y * 10));

      for (byte x = y * 7; x < (y * 7) + 7; x++) {
        if (curLocation == (x + 1)) {
          display.print("O ");
        }
        else {
          if (lootRandomizer[x] == "none") {
            display.print("- ");
          }
          else {
            display.print("X ");
          }

        }
      }
    }
    //drawBitmap();
  }
}

String bombs[21];


// Tamaboom here NOTE: runes have not been added yet
void loop3() {

  byte curLocation = 1;
  byte sweeped = 0;
  byte all = 0;

  //try creating a random loot table bomb ratio 2:3
  for (byte i = 0; i < 21; i++) {
    byte rnd = random(0, 5);
    bombs[i] = rnd >= 3 ? "O" : "B";
    if (rnd >= 3) {
      all++;
    }
  }

  display.setCursor(0, 50);
  display.print(all);
  display.print(" Gold spots!");

  while (1) {
    if (display.getButtons(TSButtonUpperLeft)) { //This is the "condition" to break out of this infinite loop.
      retMenu();
      break;
    }
    //Put whatever game function you have here
    if (display.getButtons(TSButtonLowerLeft)) { //select location next
      if (curLocation < 21) {
        curLocation += 1;
      }

    }
    if (display.getButtons(TSButtonUpperRight)) { //select location previous
      if (curLocation > 1) {
        curLocation -= 1;
      }
    }
    if (display.getButtons(TSButtonLowerRight)) { //dig dig
      //some way to save this thing

      display.setCursor(0, 50);
      if (bombs[curLocation - 1] == "O") {
        display.print("+");
        sweeped++;
        all--;
        display.print(5 * sweeped);
        display.print(" Gold, ");
        display.print(all);
        display.print(" left");
        bombs[curLocation - 1] = "X";

        gold += 5 * sweeped;

        if (all == 0) {
          display.clearWindow(0, 10, 96, 64);
          display.setCursor(0, 30);
          display.print("Yay! you win!");
          display.setCursor(0, 40);
          display.print("+100 Gold Extra!");
          gold += 100;
          delay(2000);
          //end gamehere

          retMenu();
          break;
        }

      }

      else if (bombs[curLocation - 1] == "B") { //no longer loses on one bomb, but when out of health
        hp -= 20;
        updateHP();

        if (hp <= 0) {
          display.clearWindow(0, 10, 96, 64);
          display.setCursor(0, 30);
          display.print("Boom! you lose!");
          delay(2000);
          //end gamehere

          retMenu();
          break;
        }

        display.setCursor(0, 50);
        bombs[curLocation - 1] = "X";
        display.print("Ow! HP Left: ");
        display.print(hp);

      }
      else {
        display.print("Nothing here!");
      }

    }

    display.setCursor(0, 10);
    display.print("Debug loot: ");
    display.print(curLocation);
    display.print("..");
    display.print(bombs[curLocation - 1]);

    display.setCursor(0, 20);
    for (byte y = 0; y < 3; y++) { //weird loop for 3 rows..?
      display.setCursor(0, 20 + (y * 10));

      for (byte x = y * 7; x < (y * 7) + 7; x++) {
        if (curLocation == (x + 1)) {
          display.print("O ");
        }
        else {
          if (bombs[x] == "X") {
            display.print("- ");
          }
          else {
            display.print("X ");


          }
        }

      }
    }
  }
}

byte osGhostY = 20;
void runGhost() {
  //clear previous ghost
  display.clearWindow(0, osGhostY == 20 ? 40 : 20, (osGhostY == 20 ? 40 : 20) + 20 - 1, 20 - 1);

  display.setX(10, 10 + 12 - 1);
  display.setY(osGhostY, osGhostY + 20 - 1);
  display.startData();
  display.writeBuffer(defchar, 12 * 20);
  display.endTransfer();
}

byte osObstacleX = 60; //60, 40, 20, 0
byte osObstacleY = 20; //20 or 40
void obstacle() { //this only allows one obstacle rite now
  //clear previous obstacle
  display.clearWindow(osObstacleX, osObstacleY == 20 ? 40 : 20, (osGhostY == 20 ? 40 : 20) + 20 - 1, 20 - 1);

  display.setX(10, 10 + 12 - 1);
  display.setY(osGhostY, osGhostY + 20 - 1);
  display.startData();
  display.writeBuffer(defchar, 12 * 20);
  display.endTransfer();
}

// Run .. Ghost always will hug left corner only
void loop4() {
  while (1) {
    if (display.getButtons(TSButtonUpperLeft)) { //This is the "condition" to break out of this infinite loop.
      retMenu();
      break;
    }
    if (display.getButtons(TSButtonLowerLeft)) { //go down
      if (osGhostY < 40) {
        osGhostY += 20;
      }

    }
    if (display.getButtons(TSButtonLowerRight)) { //go up
      if (osGhostY > 20) {
        osGhostY -= 20;
      }

    }
    //Put whatever game function you have here
    runGhost();
  }
}




// inventory stuff
void loop5() {
  while (1) {
    if (display.getButtons(TSButtonUpperLeft)) { //This is the "condition" to break out of this infinite loop.
      retMenu();
      break;
    }
    //Put whatever game function you have here
  }
}
